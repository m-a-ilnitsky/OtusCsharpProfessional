# Задача "Прототип"

## 1) Tables
В папке Tables расположены классы Table и Matrix, где Matrix наследуется от Table.
Оба класса реализуют интерфейсы ICopyable\<T\> и ICloneable.
Класс наследник реализует не только ICopyable<Matrix\<T\>>, но и ICopyable<Table\<T\>>.
Благодаря этому приводя класс Matrix\<T\> к интерфейсу ICopyable<Table\<T\>>, с помощью Copy() удается получить копию типа Table\<T\>.
С помощью Clone() для класса Matrix\<T\> удаётся получить только копию класса Matrix\<T\>.

## 2) Persons & Documents
В папке Persons расположены классы Person, Sitizen, Student, унаследованные друг от друга.
В папке Documents расположены классы Passport и StudentCard, использующие копирование Person с помощью Copy() для хранения "ФИО" владельца документа.
Т.к. класс Sitizen наследуется от Person, то у него реализовано два интерфейса ICopyable\<T\>: ICopyable\<Sitizen\>, ICopyable\<Person\>.
Это позволяет на основе класса Sitizen получать копии двух типов: Sitizen и Person.
Т.к. класс Student наследуется от Sitizen, то у него реализовано три интерфейса ICopyable\<T\>: ICopyable\<Student\>, ICopyable\<Sitizen\>, ICopyable\<Person\>.
Это позволяет на основе класса Student получать копии трёх типов: Student, Sitizen, Person.

## 3) Выводы

Дженерик интерфейс ICopyable\<T\> позволяет реализовать несколько реализаций метода Copy, которые можно выбрать явно.
Благодаря этому на основании одного объекта можно получать копии разных типов.
При этом тип копии точно известен.

Интерфейс ICloneable позволяет получить только один тип копии на основании экземпляра заданного типа (не обяззательно типа оригинала).
Возвращаемый тип object позволяет вернуть в качестве копии объект любого типа.
Но зато результат метода Clone() требует явного приведения типа, и если задать неверный тип код упадёт.

В текущем варианте, когда Clone() работает через вызов виртуального Copy(), метод Clone() достаточно реализовать 1 раз в базовом классе
